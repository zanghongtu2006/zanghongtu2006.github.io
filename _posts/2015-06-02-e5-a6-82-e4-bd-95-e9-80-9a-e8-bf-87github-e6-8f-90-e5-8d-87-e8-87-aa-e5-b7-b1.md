---
title: "如何通过github提升自己"
date: "2015-06-02 18:18:52"
slug: "e5-a6-82-e4-bd-95-e9-80-9a-e8-bf-87github-e6-8f-90-e5-8d-87-e8-87-aa-e5-b7-b1"
layout: "post"
categories: ["杂谈"]
tags: ["程序员", "github"]
---
如果我们仅仅是将自己的代码`commit`、`push`到github上，那么对于我们的技术不会有太多的提升。我们所做的仅仅只是将github当成了我们的网盘。
我们每发布一个版本的时候，是不是也就意味着给用户一个新的版本——持续交付。

### 敏捷软件开发

显然我是在扯淡，这和敏捷软件开发没有什么关系。不过我也不知道瀑布流是怎样的。说说我所知道的一个项目的组成吧:

* 看板式管理应用程序(如trello，简单地说就是管理软件功能)
* CI(持续集成)
* 测试覆盖率
* 代码质量(code smell)

对于一个不是远程的团队(如只有一个人的项目) 来说，Trello、Jenkin、Jira不是必需的:
> 你存在，我深深的脑海里

当只有一个人的时候，你只需要明确知道自己想要什么就够了。我们还需要的是CI、测试，以来提升代码的质量。

## 测试

通常我们都会找Document，如果没有的话，你会找什么?看源代码，还是看测试?
[codesyntax lang="javascript"]

```
it("specifying response when you need it", function (done) {
    var doneFn = jasmine.createSpy("success");

    lettuce.get('/some/cool/url', function (result) {
        expect(result).toEqual("awesome response");
        done();
    });

    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/some/cool/url');
    expect(doneFn).not.toHaveBeenCalled();

    jasmine.Ajax.requests.mostRecent().respondWith({
        "status": 200,
        "contentType": 'text/plain',
        "responseText": 'awesome response'
    });
});
```

[/codesyntax]
代码来源: <https://github.com/phodal/lettuce>
上面的测试用例，清清楚楚地写明了用法，虽然写得有点扯。
等等，测试是用来干什么的。那么，先说说我为什么会想去写测试吧:

* 我不希望每次做完一个个新功能的时候，再手动地去测试一个个功能。(自动化测试)
* 我不希望在重构的时候发现破坏了原来的功能，而我还一无所知。
* 我不敢push代码，因为我没有把握。

虽然，我不是TDD的死忠，测试的目的是保证功能正常，TDD没法让我们写出质量更高的代码。但是有时TDD是不错的，可以让我们写出逻辑更简单地代码。
也许你已经知道了`Selenium`、`Jasmine`、`Cucumber`等等的框架，看到过类似于下面的测试
[codesyntax lang="text"]

```
Ajax
   ✓ specifying response when you need it
   ✓ specifying html when you need it
   ✓ should be post to some where
 Class
   ✓ respects instanceof
   ✓ inherits methods (also super)
   ✓ extend methods
 Effect
   ✓ should be able fadein elements
   ✓ should be able fadeout elements
```

[/codesyntax]
代码来源: <https://github.com/phodal/lettuce>
看上去似乎每个测试都很小，不过补完每一个测试之后我们就得到了测试覆盖率

| File | Statements | Branches | Functions | Lines |
| --- | --- | --- | --- | --- |
| lettuce.js | 98.58% (209 / 212) | 82.98%(78 / 94) | 100.00% (54 / 54) | 98.58% (209 / 212) |

本地测试都通过了，于是我们添加了`Travis-CI`来跑我们的测试

## CI

虽然node.js不算是一门语言，但是因为我们用的node，下面的是一个简单的`.travis.yml`示例:
[codesyntax lang="text"]

```
language: node_js
node_js:
    - "0.10"

notifications:
    email: false

before_install: npm install -g grunt-cli
install: npm install
after_success: CODECLIMATE_REPO_TOKEN=321480822fc37deb0de70a11931b4cb6a2a3cc411680e8f4569936ac8ffbb0ab codeclimate < coverage/lcov.info
```

[/codesyntax]
代码来源: <https://github.com/phodal/lettuce>
我们把这些集成到`README.md`之后，就有了之前那张图。
CI对于一个开发者在不同城市开发同一项目上来说是很重要的，这意味着当你添加的部分功能有测试覆盖的时候，项目代码会更加强壮。

## 代码质量

像`jslint`这类的工具，只能保证代码在语法上是正确的，但是不能保证你写了一堆bad smell的代码。

* 重复代码
* 过长的函数
* 等等

`Code Climate`是一个与github集成的工具，我们不仅仅可以看到测试覆盖率，还有代码质量。
先看看上面的ajax类:
[codesyntax lang="javascript"]

```
Lettuce.get = function (url, callback) {
    Lettuce.send(url, 'GET', callback);
};

Lettuce.send = function (url, method, callback, data) {
    data = data || null;
    var request = new XMLHttpRequest();
    if (callback instanceof Function) {
        request.onreadystatechange = function () {
            if (request.readyState === 4 && (request.status === 200 || request.status === 0)) {
                callback(request.responseText);
            }
        };
    }
    request.open(method, url, true);
    if (data instanceof Object) {
        data = JSON.stringify(data);
        request.setRequestHeader('Content-Type', 'application/json');
    }
    request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    request.send(data);
};
```

[/codesyntax]
代码来源: <https://github.com/phodal/lettuce>
在[Code Climate](https://codeclimate.com/github/phodal/lettuce/src/ajax.js)在出现了一堆问题

* Missing "use strict" statement. (Line 2)
* Missing "use strict" statement. (Line 14)
* 'Lettuce' is not defined. (Line 5)

而这些都是小问题啦，有时可能会有

* Similar code found in two :expression\_statement nodes (mass = 86)

这就意味着我们可以对上面的代码进行重构，他们是重复的代码。

## 重构

不想在这里说太多关于`重构`的东西，可以参考Martin Flower的《重构》一书去多了解一些重构的细节。
这时想说的是，只有代码被测试覆盖住了，那么才能保证重构的过程没有出错。

# 如何通过github提升

上面所说的只是一堆堆地工具，以及一堆堆的方法，真正需要的是实践。
我们需要有测试，有CI，这样我们才能提高自己。
[待我代码编成，娶你为妻可好](http://www.xuntayizhan.com/person/ji-ke-ai-qing-zhi-er-shi-dai-wo-dai-ma-bian-cheng-qu-ni-wei-qi-ke-hao-wan/)
Follow me: <https://github.com/phodal>
原文转自：<http://www.phodal.com/blog/use-github-grow-self/>

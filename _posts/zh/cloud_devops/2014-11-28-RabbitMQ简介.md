---
title: "RabbitMQ简介"
date: "2014-11-28 12:21:57"
slug: "rabbitmq-e9-ab-98-e5-8f-af-e7-94-a8"
layout: "post"
categories: ["RabbitMQ"]
tags: ["HA", "RabbitMQ", "高可用"]
---
## RabbitMQ两个设计目标

* allowing consumers and producers to keep running in the event one Rabbit node dies
* linearly scaling messaging throughput by adding more nodes.

## RabbitMQ概念

Broker：消息队列服务器实体
Exchange：交换器，发送消息的实体，指定消息按什么规则，路由到那个队列
Queue：消息队列，一个消息会被发送到一个或多个Queue
Binding：绑定器，将交换器和队列连接起来，并且封装消息的路由信息
RoutingKey：路由关键字，Exchange根据这个关键字进行消息投递
vhost：虚拟主机，一个Broker可以开设多个vhost，用做不同用户的权限分离
producer：生产者，投递消息
consumer：消费者，接受消息
MessageData：消息数据，存储在Queue中
MetaData：路由规则数据
Connection：与RabbitMQ Server建立的一个连接，每个Connection与一个物理的Server进行连接，此连接基于socket
Channel：消息通道，建立在Connection基础上的一个通道，每个Channel代表一个会话
durable：Queue和Exchange在创建时可以指定为durable，具有这个标志，Queue和Exchange则会在重启之后重新建立，但并不保证Queue里面的MessageData会恢复。

## RabbitMQ使用

1、  获取Connection
2、  获取Channel
3、  定义Exchange，Queue
4、  使用RoutingKey将Queue Binding到一个Exchange上
5、  Client通过指定一个Exchange和一个RoutingKey将消息发送到对应的Queue上
6、  接收方在接收时，也是获取Connection，接着获取Channel，指定一个Queue到它关心的Queue上取消息

## RabbitMQ高可用

### Exchange：

Exchange在RabbitMQ中并不是一个进程，而是单纯维护了Exchange名称及其相关的binding规则。
发送消息到Exchange的本质是：连接到Channel，拿消息中的RoutingKey和binding规则匹配完成消息的路由。
真正完成路由的实体是Channel，Exchange只是规则集，我们在RabbitMQ中创建Exchange，实际是在所有节点Exchange表增加一条数据。这样，连接到所有节点，都可以使用该Exchange。

### Queue

#### 持久化

RabbitMQ会提供一些机制比如把exchange queue设置为durable，persistent mode设置为2，等等来尽可能保证消息不丢失，但是这种保证是有限的.即使你该做的都做了，RabbitMQ节点当掉还是有可能出现消息丢失的情况。这是因为RabbitMQ并没有在节点之间做数据复制(Data Replicate)。
集群中，并不是所有节点，都有Queue的完整副本，RabbitMQ只在一个节点维护该Queue的完整信息，其他节点只保存Metadata和一个Queue实际数据所在节点的指针。
如果一个Queue被声明为durable的，那么在新的节点重建这个queue会得到一个404 NOT\_FOUND错误。这种集群处理策略是为了保证这个Queue中的消息在加入集群后不消失。如果一个队列之前在node1，如果允许在节点node2重建那么后续RabbitMQ就会认为这个队列在所在的位置是在node2，之前node1未被处理的消息就不会被处理了。把这个queue加入集群的唯一方法就是等待它所在的节点恢复正常加入集群。

#### Mirrored Queue

RabbitMQ自2.6.0开始就开始支持Mirrored Queue。消息会在节点间复制，和其他主从节点一样，也有master和slave的概念，如果一个master宕掉，会在其余slave中选举一个作为master。

### MetaData

单节点：RabbitMQ会在内存中维护一份Metadata，并将标记为durable的Queue和Exchange以及相关的binding持久化到磁盘。
集群：会增加新的Metadata（集群节点位置信息，节点之间的关系），需要选择存储元数据到Ram Only或者Disk。
